[DEFNAME administrative_constants]
SM_RED=028
SM_GREEN=044
SM_BLUE=04
SM_YELLOW=036
//SM_ORANGE=02c

[PLEVEL 6]
f_connectDB

//*****************************************************************************
//*****************************************************************************
// FUNCOES
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
// f_acc_update( )
//*****************************************************************************
//[function f_acc_update]
//if ( <DB.connected> )
//if ( 0 )
//    DB.QUERY "SELECT * FROM accounts WHERE status='0'"
//    if (<DB.ROW.NUMROWS> > 0)
//        for R 0 <eval <DB.ROW.NUMROWS>-1>
//            serv.account add <DB.ROW.<eval <LOCAL.R>>.login> <eval <DB.ROW.<eval <LOCAL.R>>.password>>
//            DB.EXECUTE "UPDATE accounts SET status='1' WHERE login='<DB.ROW.<eval <LOCAL.R>>.login>'"
//            serv.log MySQL Debug: #<eval <LOCAL.R>> Account <DB.ROW.<eval <LOCAL.R>>.login> has been created!
//        end
//    endif
//endif

//*****************************************************************************
// f_connectDB( )
//*****************************************************************************
[FUNCTION f_connectDB]
DB.CONNECT
if (<DB.CONNECTED>)
	SERV.log MySQL debug: MySQL successfully connected!
else
	SERV.log MySQL debug: MySQL not connected!
endif


//*****************************************************************************
// f_sendMessage( uidPlayer, message, msgColor )
//*****************************************************************************
//envia mensagem para um player online. se estiver offline a mensagem é armazenada no banco
//e entregue no proximo login.
//
// ARGV[0] --> UID destino
// ARGV[1] --> mensagem
// ARGV[2] --> cor (SM_RED,SM_GREEN...etc)
[FUNCTION f_sendMessage]
	
//save OBJ ref.
	LOCAL.obj=<OBJ>
	
	OBJ=<argv[0]>
	if ( <OBJ.isonline> )
		OBJ.sysmessage @<argv[2]> <argv[1]>
	else
		if ( <DB.connected> )
			DB.EXECUTE "INSERT INTO messageBox SET timestamp=NOW(), message='<argv[1]>', status='Pending', triggerUid=<eval <SRC.uid>>, toUid=<eval <argv[0]>>, color=<eval <argv[2]>>"
		endif
	endif
	
	OBJ=<LOCAL.obj>
	
//*****************************************************************************
// f_deliverPendingMessages( )
//*****************************************************************************
//chame essa funcao no login para enviar as mensagens pendentes ao player.	
//SRC é o player fazendo login
[FUNCTION f_deliverPendingMessages]
if ( <DB.connected> )
    DB.QUERY "SELECT message,color FROM messageBox WHERE status='Pending' AND toUid=<eval <SRC.uid>>"
    if (<DB.ROW.NUMROWS> > 0)
        for R 0 <eval <DB.ROW.NUMROWS>-1>
			SRC.sysmessage @<DB.ROW.<eval <LOCAL.R>>.color> <DB.ROW.<eval <LOCAL.R>>.message>
        end
        DB.EXECUTE "UPDATE messageBox SET status='Sent' WHERE toUid=<eval <SRC.uid>>"
    endif
endif
	

//*****************************************************************************
// f_isWeapon( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeapon]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_weapon_axe )
		return 1
	elif ( <LOCAL.type>==t_weapon_mace_smith )
		return 1
	elif ( <LOCAL.type>==t_weapon_mace_sharp )
		return 1
	elif ( <LOCAL.type>==t_weapon_sword )
		return 1
	elif ( <LOCAL.type>==t_weapon_fence )
		return 1
	elif ( <LOCAL.type>==t_weapon_bow )
		return 1
	elif ( <LOCAL.type>==t_weapon_mace_staff )
		return 1
	elif ( <LOCAL.type>==t_weapon_mace_crook )
		return 1
	elif ( <LOCAL.type>==t_weapon_mace_pick )
		return 1
	elif ( <LOCAL.type>==t_weapon_arrow )
		return 1
	elif ( <LOCAL.type>==t_weapon_bolt )
		return 1
	elif ( <LOCAL.type>==t_weapon_xbow )
		return 1
	elif ( <LOCAL.type>==t_string )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// f_isArmor( item )
//*****************************************************************************
//retorna 1 se o argumento for uma armadura (ou escudo)
[FUNCTION f_isArmor]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_armor )
		return 1
	elif ( <LOCAL.type>==t_armor_leather )
		return 1
	elif ( <LOCAL.type>==t_shield )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// f_isRegsOrMagic( item )
//*****************************************************************************
//retorna 1 se o argumento for uma reagente ou magico
[FUNCTION f_isRegsOrMagic]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_wand )
		return 1
	elif ( <LOCAL.type>==t_potion )
		return 1
	elif ( <LOCAL.type>==t_potion_empty )
		return 1
	elif ( <LOCAL.type>==t_reagent )
		return 1
	elif ( <LOCAL.type>==t_reagent_raw )
		return 1
	elif ( <LOCAL.type>==t_reagente )
		return 1
	elif ( <LOCAL.type>==t_almofariz )
		return 1
	elif ( <LOCAL.type>==t_espiriteira )
		return 1
	elif ( <LOCAL.type>==t_destilador )
		return 1
	elif ( <LOCAL.type>==t_balao )
		return 1
	elif ( <LOCAL.type>==t_misturador )
		return 1
	elif ( <LOCAL.type>==t_tubo )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// f_isFood( item )
//*****************************************************************************
//retorna 1 se o argumento for um alimento/comestivel
[FUNCTION f_isFood]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_food )
		return 1
	elif ( <LOCAL.type>==t_food_raw )
		return 1
	elif ( <LOCAL.type>==t_fish )
		return 1
	elif ( <LOCAL.type>==t_drink )
		return 1
	elif ( <LOCAL.type>==t_fruit )
		return 1
	elif ( <LOCAL.type>==t_meat_raw )
		return 1
	elif ( <LOCAL.type>==t_pitcher )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// f_isMisc( item )
//*****************************************************************************
//retorna 1 se o argumento for ferramenta, movel, etc
[FUNCTION f_isMisc]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_clock )
		return 1
	elif ( <LOCAL.type>==t_musical )
		return 1
	elif ( <LOCAL.type>==t_ar_projeto )
		return 1
	elif ( <LOCAL.type>==t_carpentry )
		return 1
	elif ( <LOCAL.type>==t_chair )
		return 1
	elif ( <LOCAL.type>==t_sextant )
		return 1
	elif ( <LOCAL.type>==t_table )
		return 1
	elif ( <LOCAL.type>==t_fish_pole )
		return 1
	elif ( <LOCAL.type>==t_shaft )
		return 1
	elif ( <LOCAL.type>==t_tinker_tools )
		return 1
	elif ( <LOCAL.type>==t_light_out )
		return 1
	elif ( <LOCAL.type>==t_fish_pole )
		return 1
	elif ( <LOCAL.type>==t_oleo )
		return 1
	elif ( <LOCAL.type>==t_book )
		return 1
	elif ( <LOCAL.type>==t_sand )
		return 1
	elif ( <LOCAL.type>==t_recipiente )
		return 1
	elif ( <LOCAL.type>==t_preitem_bowcraft )
		return 1
	elif ( <LOCAL.type>==t_arame )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// f_isWearable( item )
//*****************************************************************************
//retorna 1 se o argumento for roupas, joias, etc
[FUNCTION f_isWearable]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_clothing )
		return 1
	elif ( <LOCAL.type>==t_cloth )
		return 1
	elif ( <LOCAL.type>==t_tailoring )
		return 1
	elif ( <LOCAL.type>==t_thread )
		return 1
	elif ( <LOCAL.type>==t_yarn )
		return 1
	elif ( <LOCAL.type>==t_jewelry )
		return 1
	elif ( <LOCAL.type>==t_bandagem )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// f_isRaw( item )
//*****************************************************************************
//retorna 1 se o argumento for materia prima
[FUNCTION f_isRaw]
	LOCAL.type = <uid.<argn>.type>
	if ( <LOCAL.type>==t_log )
		return 1
	elif ( <LOCAL.type>==t_ore )
		return 1
	elif ( <LOCAL.type>==t_ingot )
		return 1
	elif ( <LOCAL.type>==t_semente )
		return 1
	elif ( <LOCAL.type>==t_leather )
		return 1
	elif ( <LOCAL.type>==t_loom )
		return 1
	elif ( <LOCAL.type>==t_feather )
		return 1
	elif ( <LOCAL.type>==t_wool )
		return 1
	elif ( <LOCAL.type>==t_fur )
		return 1
	elif ( <LOCAL.type>==t_thread )
		return 1
	elif ( <LOCAL.type>==t_yarn )
		return 1
	elif ( <LOCAL.type>==t_cotton )
		return 1
	elif ( <LOCAL.type>==t_preitem_bowcraft )
		return 1
	elif ( <LOCAL.type>==t_arame )
		return 1
	else
		return 0
	endif

//*****************************************************************************
// wipeObject <DEFNAME> Remove todos os itens <DEFNAME> do world.
//*****************************************************************************
[FUNCTION wipeObject]
IF !(<ARGN>)
 IF (<ISEMPTY <DEF.<ARGS>>>)
  SYSMESSAGE <args> nao existe.
  RETURN 0
 endif
endif
IF !(<ISEMPTY <ARGS>>)
 IF !(<SERV.ITEMDEF.<ARGS>>) && !(<SERV.CHARDEF.<ARGS>>)
  SYSMESSAGE <ARGS> nao eh um item nem criatura.
  RETURN 0
 endif
 FORINSTANCES <argv[0]>
  LOCAL.wipe=<local.wipe>+1
  remove
 ENDFOR
 sysmessageorange Removidos <eval <LOCAL.wipe>> instancias de <SERV.RESOURCES.<argv[0]>.NAME>
endif

//*****************************************************************************
//	CRY	Faz o char gritar de dor e animar (compatibilidade com 55i)
//*****************************************************************************

[FUNCTION cry]
//// anima
anim 20						//Animação de @GetHit
bark 2

//*****************************************************************************
//	EFFECTSPELL <spell>,<skill>
//*****************************************************************************
//Retorna o EFFECT de uma magia de acordo com uma skill
[FUNCTION EFFECTSPELL]
LOCAL.eff=<SERV.RESOURCES.<argv0>.EFFECT>
LOCAL.min=<strarg <LOCAL.eff>>
LOCAL.eff=<EVAL {<LOCAL.min> <streat <LOCAL.eff>>}>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
RETURN <LOCAL.eff>

//*****************************************************************************
//	DAMAGESPELL <spell>,<dam_type>,<skill>,<UIDcaster>
//*****************************************************************************
//Danifica conforme a magia <argv0> com tipo <argv1> como se tivesse magery <argv2> por <<argv3>.UID>
[FUNCTION damagespell]
LOCAL.dam=<EFFECTSPELL <argv0>, <argv2>>
DAMAGE <LOCAL.dam> <EVAL <argv1>> <argv3>							//aplica o dano com o tipo modificado
RETURN <LOCAL.dam>

//*****************************************************************************
//	IsStonned
//*****************************************************************************
//Retorna se o char está stonnado ou não.
[FUNCTION IsStonned]
if (<restest 1 i_stonned>)
 RETURN 1
else
 RETURN 0
endif

//*****************************************************************************
//	Stonned <tempo>
//*****************************************************************************
//Petrifica um char por <tempo> segundos.
[FUNCTION Stonned]
if (<IsStonned>)
 RETURN 0
endif
serv.newitem i_stonned
new.timer=<argn>
equip <new.uid>
RETURN 1

[ITEMDEF i_stonned]
ID=020A5
NAME=Petrificado
TYPE=t_eq_script
LAYER=layer_special

on=@equip
cont.flags=<cont.flags>|040000
cont.update

on=@timer
cont.flags=<cont.flags>&~040000
cont.sysmessageblue Voce nao esta mais petrificado.
cont.update
remove
RETURN 1

//*****************************************************************************
// emotes
//*****************************************************************************
[FUNCTION emotegreen]
SAY @044,  *<args>*

[FUNCTION emotered]
SAY @028,  *<args>*

[FUNCTION emoteyellow]
SAY @036,  *<args>*

[FUNCTION emoteorange]
SAY @02c,  *<args>*

//*****************************************************************************
// sysmessage
//*****************************************************************************
[FUNCTION sysmessagered]
SYSMESSAGE @028,3  <args>

[FUNCTION sysmessageblue]
SYSMESSAGE @004,3  <args> 

[FUNCTION sysmessagegreen]
SYSMESSAGE @044,3  <args> 

[FUNCTION sysmessageyellow]
SYSMESSAGE @036,3  <args> 

[FUNCTION sysmessageorange]
SYSMESSAGE @02c,3  <args> 

//*****************************************************************************
// decrement
//*****************************************************************************
[FUNCTION decrement]
amount=<amount>-1
if (<amount><1)
	remove
endif
update

//*****************************************************************************
// f_sendTooltip(title,text)
//*****************************************************************************
[FUNCTION f_sendTooltip]
src.addcliloc 1042971,<argv0>
src.addcliloc 1070722,<argv1>

//*****************************************************************************
// f_sendTooltipData(text)
//*****************************************************************************
[FUNCTION f_sendTooltipData]
src.addcliloc 1070722,<argv0>

//*****************************************************************************
// checkVersion([major],[lower],[minor])
//*****************************************************************************
[FUNCTION checkVersion]
if (!0<argv0>)
	return <f_checkVersion <STREAT <explode .,<CLIENTVERSION>>>>
endif
if (<argv0>==6) && (<argv1>==0) && (<argv2>==1)
	src.sysmessageyellow ****************************************************Versao de client 6.0.1.7 CAUSA problemas.
	return 1
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
	return 1
endif
return 0

//*****************************************************************************
// f_checkVersion(major,lower,minor)
//*****************************************************************************
[FUNCTION f_checkVersion]
if (!0<argv0>)
	serv.log Clientversion invalido: <CLIENTVERSION> -- <argv0>::<argv1>::<argv2>
	return 0
endif
if (<argv0>==6) && (<argv1>==0) && (<argv2>==1)
	src.sysmessageyellow ****************************************************Versao de client 6.0.1.7 CAUSA problemas.
	return 1
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
	return 1
endif
return 0

//*****************************************************************************
// f_spreadValue(value,error)
//*****************************************************************************
//dado um valor value, retorn um valor aleatorio V+-K, onde K vai de 0 a
//(V/2) (erro 100%)
//'error' deve ser passado entre 0 (retorna 'value') e Cm (atualmente 50)

//Formula e simplificavao:
//Vn=V*[1+(2*Er-Em)/(2*Cm)]
//Vn=V*[(2*Cm)+(2*Er)-Em)]/(2*Cm)
//Vn=V*[K-Em+(2*Er)]/k
//Vn - valor falso
//V  - valor real ('value')
//Cm - Maximo % de erro (0 a 100). Atualmente ajustado em 50.
//Em - Erro máximo ('error')
//Er - Erro random (0 a Em)
[FUNCTION f_spreadValue]
return <eval (<argv0>*((100-<argv1>)+(2*<R0,<argv1>>)))/100>

//*****************************************************************************
// f_rangeValue(min,max,skill)
//*****************************************************************************
//dado um valor value, retorn um valor de acordo com uma regra de tres
//composta entre <min> e <max> de acordo com <skill>
[FUNCTION f_RangeValue]
LOCAL.min=<argv0>
LOCAL.max=<argv1>
LOCAL.skill=<argv2>
LOCAL.max=<LOCAL.max>-<LOCAL.min>
LOCAL.max=((<LOCAL.max>*<LOCAL.skill>)/1000)+<LOCAL.min>
return <eval <LOCAL.max>>

//*****************************************************************************
// f_isDisturbed()
//*****************************************************************************
//verifica se ha algum flag de perturbacao:
//statf_hallucinating|statf_fly|statf_stone|statf_polymorph|statf_war|statf_sleeping|statf_freeze|statf_dead
[FUNCTION f_isDisturbed]
if (<flags>&000540436)
	return 1
endif
return 0

//*****************************************************************************
// f_gmLog( text )
//*****************************************************************************
//exibe sysmensage para gms dentro da area da tela
[FUNCTION f_gmLog]
FORCLIENTS
	if (<gm>)
		sysmessageyellow <args>
	endif
ENDFOR


//*****************************************************************************
// f_npcRunStepToUid( uid_to_go, steps )
//*****************************************************************************
//npc corre em dire  o ao UID
//default: NPC que ira correr
//uid_to_go: uid alvo
//steps numero de 'run's que ira dar em direcao ao alvo
[FUNCTION f_npcRunStepToUid]
REF1=<argv0>
LOCAL.dx = <eval <REF1.p.x>-<p.x>>
LOCAL.dy = <eval <REF1.p.y>-<p.y>>

LOCAL.run=0
if ( <LOCAL.dx> > 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SE
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NE
       else
               LOCAL.run=E
       endif
elif ( <LOCAL.dx> < 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SW
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NW
       else
               LOCAL.run=W
       endif
else
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=S
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=N
       endif
endif

if !( 0<LOCAL.run>==0 )
       for R <argv1>
               run <LOCAL.run>
       endfor
       return 1
endif

return 0


//*****************************************************************************
// HILIGHT <UID>, <COLOR>
//*****************************************************************************
//Faz <UID> parecer ter cor <color> pada o default por 3 segundos.
[FUNCTION hilight]
OBJ=<argv0>
LOCAL.y=<eval <obj.p.y>|08000>
SENDPACKET 01A W16 D<obj.uid> W<obj.dispiddec> W<obj.p.x> W<LOCAL.y> B<obj.p.z> W<argv1>
obj.timerf 3,update

//*****************************************************************************
// blindItemMsg <UID>, <COLOR>, <message>
//*****************************************************************************
//Faz <UID> mandar <message> em <color> para o default.
[function blindItemMsg]
sendpacket 01c W<hval strlen(<argv2>) + 45> D<argv0> W0FFFF B07 W<argv1> W03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 <asc <ARGV2>> 00

//*****************************************************************************
// dumpChar
//*****************************************************************************
//faz um dump completo do char na console
[FUNCTION dumpChar]
serv.log *********************** DUMP CHAR *************************
serv.log UID:<uid> F:<flags> ACCT:<account> NAME:<tag.name>
serv.log ************************* EQUIP ***************************
for layer 1 24
	obj=<findlayer.<local.layer>>
	if (<obj>)
		serv.log U:<obj> A:<obj.attr> T:<obj.timer> B:<obj.baseid> L:<LOCAL.layer> N:<obj.name>
	endif
endfor
serv.log *********************** MEMORIES **************************
forcharlayer 30
	serv.log U:<uid> A:<attr> T:<timer> B:<baseid> N:<name>
endfor
serv.log ************************ EVENTS ***************************
LOCAL.c=<events>
while (!strmatch(<LOCAL.c>,0))
	serv.log <strarg <LOCAL.c>>
	LOCAL.c=<streat <LOCAL.c>>
end
serv.log ************************* TAGS ****************************
LOCAL.c=<eval <tagcount>-1>
for i 0 <LOCAL.c>
	serv.log <tagat.<local.i>>
endfor
serv.log ***************** CTAGS [CONSOLE ONLY] ********************
ctaglist log
serv.log *********************** END DUMP **************************

[EOF]